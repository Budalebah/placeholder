//---------------------------------------------------------------------------//
// Copyright (c) 2024 Valeh Farzaliyev <estoniaa@nil.foundation>
//
// MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//---------------------------------------------------------------------------//
// @file Object, that helps to transform dfri proof to public input column for dfri recursive circuit
//---------------------------------------------------------------------------//
#ifndef BLUEPRINT_COMPONENTS_FLEXIBLE_VERIFIER_DFRI_PROOF_INPUT_TYPE_HPP
#define BLUEPRINT_COMPONENTS_FLEXIBLE_VERIFIER_DFRI_PROOF_INPUT_TYPE_HPP

#include <map>

#include <nil/crypto3/math/polynomial/polynomial.hpp>
#include <nil/crypto3/math/algorithms/calculate_domain_set.hpp>

#include <nil/crypto3/zk/snark/arithmetization/plonk/constraint_system.hpp>
#include <nil/crypto3/zk/snark/systems/plonk/placeholder/preprocessor.hpp>
#include <nil/crypto3/zk/snark/systems/plonk/placeholder/proof.hpp>

namespace nil {
    namespace blueprint {
        namespace components {
            namespace detail {
                template<typename PlaceholderParams>
                class dfri_proof_input_type {
                public:
                    using field_type = typename PlaceholderParams::field_type;
                    using value_type = typename field_type::value_type;
                    using var = crypto3::zk::snark::plonk_variable<value_type>;

                    using proof_type =
                        nil::crypto3::zk::snark::placeholder_proof<field_type,
                                                                   typename PlaceholderParams::placeholder_params>;
                    using common_data_type = typename nil::crypto3::zk::snark::placeholder_public_preprocessor<
                        field_type,
                        PlaceholderParams>::preprocessed_data_type::common_data_type;
                    using constraint_system_type = typename PlaceholderParams::constraint_system_type;
                    using placeholder_info_type = nil::crypto3::zk::snark::placeholder_info<PlaceholderParams>;

                    dfri_proof_input_type(const typename PlaceholderParams::commitment_scheme_params_type &fri_params,
                                          const std::size_t evaluation_points_num,
                                          const std::map<std::pair<std::size_t, std::size_t>, std::pair<std::size_t, std::size_t>>& evaluation_map,
                                          std::size_t start_row_index = 0) :
                        common_data(common_data), constraint_system(constraint_system), fri_params(fri_params),
                        evaluation_points_num(evaluation_points_num), eval_map(evaluation_map) {
                        placeholder_info = nil::crypto3::zk::snark::prepare_placeholder_info<PlaceholderParams>(
                            constraint_system, common_data);

                        fill_vector();
                    }

                public:
                    std::vector<var> vector() {
                        return var_vector;
                    }
                    std::vector<var> fri_roots() const {
                        return _fri_roots;
                    }
                    var challenge() const {
                        return _challenge;
                    }
                    const std::vector<var> &evaluation_points() const {
                        return _evaluation_points;
                    }
                    const std::vector<var> &evaluations() const {
                        return _evaluations;
                    }
                    const std::vector<std::vector<var>> &merkle_tree_positions() const {
                        return _merkle_tree_positions;
                    }
                    const std::vector<std::vector<var>> &initial_proof_values() const {
                        return _initial_proof_values;
                    }
                    const std::vector<std::vector<var>> &initial_proof_hashes() const {
                        return _initial_proof_hashes;
                    }
                    const std::vector<std::vector<var>> &round_proof_values() const {
                        return _round_proof_values;
                    }
                    const std::vector<std::vector<var>> &round_proof_hashes() const {
                        return _round_proof_hashes;
                    }

                protected:
                    var _challenge;
                    std::vector<var> _evaluation_points;
                    std::vector<var> _evaluations;
                    std::vector<var> _fri_roots;
                    std::vector<std::vector<var>> _merkle_tree_positions;
                    std::vector<std::vector<var>> _initial_proof_values;
                    std::vector<std::vector<var>> _initial_proof_hashes;
                    std::vector<std::vector<var>> _round_proof_values;
                    std::vector<std::vector<var>> _round_proof_hashes;

                    void fill_vector() {
                        auto &desc = common_data.desc;

                        std::size_t cur = 0;

                        // Evaluation points
                        _evaluation_points.resize(evaluation_points_num);
                        for (std::size_t i = 0; i < evaluation_points_num; i++) {
                            _evaluation_points[i] = var(0, cur++, false, var::column_type::public_input);
                            var_vector.push_back(_evaluation_points[i]);
                        }

                        // Batched evaluations
                        std::size_t itr = 0;
                        for(auto &[k, v]: eval_map){
                            _evaluations[itr++] = var(0, cur++, false, var::column_type::public_input);
                            var_vector.push_back(_evaluations[itr]);
                        }

                        // Challenge
                        _challenge = var(0, cur++, false, var::column_type::public_input);
                        var_vector.push_back(_challenge);
                        // FRI roots
                        for (std::size_t i = 0; i < fri_params.r; i++) {
                            _fri_roots.push_back(var(0, cur++, false, var::column_type::public_input));
                            var_vector.push_back(_fri_roots[i]);
                        }

                        // Query proofs
                        _merkle_tree_positions.resize(fri_params.lambda);
                        _initial_proof_values.resize(fri_params.lambda);
                        _initial_proof_hashes.resize(fri_params.lambda);
                        _round_proof_values.resize(fri_params.lambda);
                        _round_proof_hashes.resize(fri_params.lambda);
                        std::cout << "Poly input num = " << placeholder_info.poly_num << std::endl;
                        for (std::size_t i = 0; i < fri_params.lambda; i++) {
                            // Initial proof values
                            _initial_proof_values[i] = {};
                            for (std::size_t j = 0; j < placeholder_info.poly_num; j++) {
                                auto val0 = var(0, cur++, false, var::column_type::public_input);
                                auto val1 = var(0, cur++, false, var::column_type::public_input);
                                _initial_proof_values[i].push_back(val0);
                                _initial_proof_values[i].push_back(val1);
                                var_vector.push_back(val0);
                                var_vector.push_back(val1);
                            }
                            // Initial proof positions
                            _merkle_tree_positions[i].resize(log2(fri_params.D[0]->m) - 1);
                            for (std::size_t j = 0; j < log2(fri_params.D[0]->m) - 1; j++) {
                                var pos_var = var(0, cur++, false, var::column_type::public_input);
                                var_vector.push_back(pos_var);
                                _merkle_tree_positions[i][j] = pos_var;
                            }
                            // Initial proof hashes
                            for (std::size_t j = 0; j < placeholder_info.batches_num * (log2(fri_params.D[0]->m) - 1);
                                 j++) {
                                var hash_var = var(0, cur++, false, var::column_type::public_input);
                                var_vector.push_back(hash_var);
                                _initial_proof_hashes[i].push_back(hash_var);
                            }
                            // Round proof values
                            for (std::size_t j = 0; j < fri_params.r; j++) {
                                var y0_var = var(0, cur++, false, var::column_type::public_input);
                                var y1_var = var(0, cur++, false, var::column_type::public_input);
                                var_vector.push_back(y0_var);
                                var_vector.push_back(y1_var);
                                _round_proof_values[i].push_back(y0_var);
                                _round_proof_values[i].push_back(y1_var);
                            }
                            // Round proof hashes
                            for (std::size_t j = 0; j < placeholder_info.round_proof_layers_num; j++) {
                                var hash_var = var(0, cur++, false, var::column_type::public_input);
                                var_vector.push_back(hash_var);
                                _round_proof_hashes[i].push_back(hash_var);
                            }
                        }
                        // Final polynomials
                        std::size_t final_polynomial_size =
                            std::pow(2, std::log2(fri_params.max_degree + 1) - fri_params.r + 1) - 2;
                        for (std::size_t i = 0; i < final_polynomial_size; i++) {
                            var_vector.push_back(var(0, cur++, false, var::column_type::public_input));
                        }
                    }

                private:
                    const common_data_type &common_data;
                    const constraint_system_type &constraint_system;
                    std::vector<var> var_vector;
                    const typename PlaceholderParams::commitment_scheme_params_type &fri_params;
                    placeholder_info_type placeholder_info;
                    std::map<std::pair<std::size_t, std::size_t>, std::pair<std::size_t, std::size_t>> eval_map;
                    std::size_t evaluation_points_num;
                };
            }    // namespace detail
        }    // namespace components
    }    // namespace blueprint
}    // namespace nil

#endif
